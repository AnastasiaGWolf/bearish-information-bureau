## React вопросы

### 1. Что такое хуки в React?

Хуки - это новая функция, добавленная в React v16.8. Хуки позволяют использовать все возможности React без написания классовых компонентов. Например, до версии 16.8 для управления состоянием компонента нам нужен классовый компонент. Теперь мы можем сохранять состояние в функциональном компоненте с помощью хука useState.

- Будут ли хуки React работать внутри классовых компонентов?
- Нет

### 2. Зачем были введены хуки в React?

- Одной из причин введения хуков была сложность работы с ключевым словом this внутри классовых компонентов. Если с ним не обращаться должным образом, this будет иметь несколько другое значение. Это приведет к поломке таких строк, как this.setState() и других обработчиков событий. Используя хуки, мы избегаем этой сложности при работе с функциональными компонентами.
- Классовые компоненты не очень хорошо минимизируются, а также делают горячую перезагрузку ненадежной. Это еще одна причина для создания хуков.
- Другая причина в том, что не существует конкретного способа повторно использовать логику компонента, наделенного состоянием. Несмотря на то, что HOC (Higher-Order Component) и шаблоны Render Props (метод передачи props от родителя ребенку, используя функцию или замыкание) решают эту проблему, здесь требуется изменить код классового компонента. Хуки позволяют совместно использовать логику с отслеживанием состояния без изменения иерархии компонентов.
- Четвертая причина заключается в том, что в сложном классовом компоненте связанный код разбросан по разным методам жизненного цикла. Например, в случае загрузки данных (fetch) мы делаем это в основном в componentDidMount() и componentDidUpdate(). Другой пример: в случае слушателей событий мы используем componentDidMount() для подписки на события и componentWillUnmount() для отмены подписки. Вместо этого хуки помогают объединить связанный код.

### 3. Как работает хук useState?

Хук useState - это функция, которая используется для хранения состояния в функциональном компоненте. Он принимает аргумент как начальное значение состояния и возвращает массив с 2 элементами. Первый элемент - это текущее значение состояния. Второй элемент - это функция обновления состояния.

### 3.2. Каковы различия в использовании хуков и классовых компонентов в отношении управления состоянием?

При использовании setState() в классовых компонентах переменная состояния всегда является объектом. В то время как переменная состояния в хуках может иметь любой тип, например, число, строку, логическое значение, объект или массив.  
Когда переменная состояния является объектом, setState() в классовых компонентах автоматически объединяет новое значение с объектом состояния. Но в случае функции обновления состояния в useState() нам нужно явно объединить обновленное свойство объекта с помощью spread оператора.

### 4. Зачем нужен хук useEffect?

Хук useEffect позволяет нам выполнять побочные эффекты в функциональных компонентах. Это помогает нам избежать избыточного кода в различных методах жизненного цикла классового компонента. Это помогает сгруппировать связанный код.

### 5. Что делает хук useEffect в React

useEffect позволяет выполнять побочные эффекты в функциональных компонентах. Могут быть операции, которые выходят за рамки возвращаемого результата рендеринга (запрос данных, подписки, таймеры, ручное изменения DOM и тд). Запускается после каждого рендеринга компонента по умолчанию, поведение настраивается с помощью массива зависимостей.

### 6. Как работает массив зависимостей?

Массив зависимостей - второй (необязательный) аргумент, передаваемый в хук. Представляет собой массив значений, от которых зависит эффект.

- Массив не предоставлен - эффект выполняется после каждого рендера
- [] - эффект выполняться только один раз при монтировании компонента, аналогично componentDidMount в классовых компонентах
- [ переменные ] - эффект выполняется при изменении переменных.

### 7. Как осуществляется очистка в useEffect?

Для очистки в useEffect, функция, передаваемая в useEffect, может вернуть функцию очистки. React вызовет эту функцию перед тем, как компонент будет размонтирован, а так же перед следующим выполнение эффекта, если он повторно активируется. Используется для предотвращения утечек памяти.  
Пример использования очистки:

```javascript
import { useEffect, useState } from "react";

export default function Timer(): JSX.Element {
  const [count, setCount] = useState < number > 20;

  useEffect(() => {
    const timeCounter = setTimeout(() => {
      if (count > 0) {
        setCount((prev) => prev - 1);
      }
    }, 200);
    return () => clearTimeout(timeCounter); // функция очистки
  }, [count]);

  return <h2>{count ? `Timer: ${count}` : "Время вышло!"}</h2>;
}
```

### 8. Как избежать бесконечных циклов при использовании useEffect?

Бесконечные циклы возникают например, когда эффект обновляет состояние, на которое он сам зависит, без правильной настройки массива зависимостей. Для избежания этого необходимо проверить:

- Все перемененные, которые используются в эффекте и могут изменяться, включены в массив зависимостей;
- Используется пустой массив зависимостей, если эффект должен срабатывать только при монтировании и размонтировании;
- Следует избегать изменения состояния в эффекте, если это изменений может повторно активировать тот же эффект (только если это нее является преднамеренным поведением)ю

### 9. Разница между использованием useEffect и useLayoutEffect?

Оба хука позволяют выполнять дополнительные эффекты, такие как вызовы API, настройку подписок и манипулирование DOM вручную в функциональном компоненте, но при этом:

- **useLayoutEffect** выполняется синхронно до того, как браузер отрисует (обновит) эти обновления для просмотра пользователями. Подходит для чтения из DOM или для изменений, которые необходимо отобразить перед следующим отображение экрана, чтобы избежать возможного мерцания. Но так браузер не может отображать какие-либо обновления, пока не запустится useLayoutEffect. По этой причине в основном используется useEffect

- **useEffect** выполняется асинхронно после того, как браузер отрисует (обновит) экран. Является более подходящим для большинства дополнительных / побочных эффектов

**Код с использованием useEffect:**  
**DOM обновления** => _Браузер отображает обновление для просмотра пользователем_ => useEffect => **другое обновление DOM** => _Браузер отображает второе обновление для просмотра пользователем_

**Код с использованием useLayoutEffect:**  
**DOM обновления** => useLayoutEffect => **другое обновление DOM** => _Браузер отображает общее обновление для просмотра пользователем_

### 10.
