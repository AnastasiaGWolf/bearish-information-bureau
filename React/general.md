## React вопросы

### 1. Что такое хуки в React?

Хуки - это новая функция, добавленная в React v16.8. Хуки позволяют использовать все возможности React без написания классовых компонентов. Например, до версии 16.8 для управления состоянием компонента нам нужен классовый компонент. Теперь мы можем сохранять состояние в функциональном компоненте с помощью хука `useState`.

- Будут ли хуки React работать внутри классовых компонентов?
- Нет

### 2. Зачем были введены хуки в React?

- Одной из причин введения хуков была сложность работы с ключевым словом `this` внутри классовых компонентов. Если с ним не обращаться должным образом, `this` будет иметь несколько другое значение. Это приведет к поломке таких строк, как `this.setState()` и других обработчиков событий. Используя хуки, мы избегаем этой сложности при работе с функциональными компонентами.
- Классовые компоненты не очень хорошо минимизируются, а также делают горячую перезагрузку ненадежной. Это еще одна причина для создания хуков.
- Другая причина в том, что не существует конкретного способа повторно использовать логику компонента, наделенного состоянием. Несмотря на то, что HOC (Higher-Order Component) и шаблоны Render Props (метод передачи props от родителя ребенку, используя функцию или замыкание) решают эту проблему, здесь требуется изменить код классового компонента. Хуки позволяют совместно использовать логику с отслеживанием состояния без изменения иерархии компонентов.
- Четвертая причина заключается в том, что в сложном классовом компоненте связанный код разбросан по разным методам жизненного цикла. Например, в случае загрузки данных (fetch) мы делаем это в основном в `componentDidMount()` и `componentDidUpdate()`. Другой пример: в случае слушателей событий мы используем `componentDidMount()` для подписки на события и `componentWillUnmount()` для отмены подписки. Вместо этого хуки помогают объединить связанный код.

### 3. Какие хуки вы знаете?

| Хук                                        | Используется для...                                                                                                     |
| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| [useState](/React/useState/)               | управления состоянием в функциональных компонентах                                                                      |
| [useEffect](/React/useEffect/)             | выполнения побочных эффектов в функциональных компонентах (например, для получения данных или подписки на события)      |
| [useContext](/React/useContext/)           | доступа к значению контекста React в функциональном компоненте                                                          |
| [useRef](/React/useRef/)                   | создания изменяемых ссылок на элементы или значения, которые сохраняются во время рендеринга                            |
| [useCallback](/React/useCallback/)         | мемоизации функций для предотвращения ненужных повторных рендеров                                                       |
| [useMemo](/React/useMemo/)                 | запоминания значений с целью повышения производительности за счет кэширования ресурсоемких вычислений                   |
| [useReducer](/React/useReducer/)           | управления состоянием с помощью функции reducer, аналогично тому, как это делается в Redux                              |
| [useLayoutEffect](/React/useLayoutEffect/) | выполнения побочных эффектов подобно useEffect, с той разницей, что эффект запускается синхронно после всех мутаций DOM |

### 4. Что такое виртуальный DOM?

Виртуальный DOM в React – концепция создания и хранения в памяти облегченного виртуального представления реального DOM (объектной модели документа). Этот подход помогает оптимизировать производительность веб-приложений:

- Если данные или состояние React-компонента изменяются, вместо прямых манипуляций с реальной DOM-моделью обновляется виртуальная.
- Затем в виртуальной модели DOM вычисляется разница между предыдущим и обновленным состоянием компонента (с помощью diffing-алгоритма, сравнения деревьев по внутренним узлам).
- После выявления различий React эффективно обновляет только необходимые части реальной DOM для отражения изменений.

Использование виртуального DOM позволяет React создавать динамичные и интерактивные пользовательские интерфейсы, обеспечивая при этом оптимальную эффективность и скорость рендеринга.

### 5. Как выполнить рендеринг элементов массива?

Для рендеринга статического списка можно использовать метод map(), который перебирает элементы и возвращает новый массив элементов React.

Для рендеринга элементов динамического списка добавляется использование ключей. Они необходимы для оптимизации процесса рендеринга, позволяя React быстро определить, какие элементы были изменены, удалены или добавлены.

### 6. Чем управляемые компоненты отличаются от неуправляемых?

Разница между управляемыми и неуправляемыми компонентами заключается в том, как они управляют своим состоянием и обновляют его.

**Управляемые компоненты** – это компоненты, состояние которых контролируется React. Компонент получает свое текущее значение и обновляет его через реквизиты (пропсы). При изменении значения он также запускает функцию обратного вызова. Это означает, что компонент не хранит собственное внутреннее состояние – вместо этого родительский компонент управляет им и передает значение управляемому компоненту.

```javascript
import { useState } from "react";

function App() {
  const [value, setValue] = useState("");

  return (
    <div>
      <h3>Controlled Component</h3>
      <input
        name="name"
        value={name}
        onChange={(e) => setValue(e.target.value)}
      />
      <button onClick={() => console.log(value)}>Get Value</button>
    </div>
  );
}
```

**Неуправляемые компоненты**, напротив, управляют своим состоянием самостоятельно с помощью ссылок или других методов. Они хранят и обновляют свое состояние самостоятельно, не полагаясь на реквизиты или обратные вызовы. Родительский компонент имеет меньший контроль над состоянием неуправляемых компонентов.

```javascript
import { useRef } from "react";

function App() {
  const inputRef = useRef(null);

  return (
    <div className="App">
      <h3>Uncontrolled Component</h3>
      <input type="text" name="name" ref={inputRef} />
      <button onClick={() => console.log(inputRef.current.value)}>
        Get Value
      </button>
    </div>
  );
}
```

И немного подробнее про управляемые компоненты и зачем нам нужна функция `changeHandler` в картинках:

![alt text](/assets/image.png)

### 7. Что такое методы жизненного цикла компонента?

Методы жизненного цикла – это способ подключения к различным этапам жизненного цикла компонента, позволяющий выполнять определенный код в определенное время. Список основных методов:
- **constructor** – первый метод, вызываемый при создании компонента. Он используется для инициализации состояния и привязки обработчиков событий. В функциональных компонентах для аналогичных целей используется хук `useState`.
- **render** – отвечает за рендеринг JSX-разметки и возвращает содержимое, которое будет выведено на экран.
- **componentDidMount** – вызывается сразу после рендеринга компонента в DOM. Обычно используется для задач инициализации, таких как вызов API или настройка слушателей событий.
- **componentDidUpdate** – вызывается при изменении реквизитов или состояния компонента. Позволяет выполнять побочные эффекты, обновлять компонент на основе изменений или запускать дополнительные вызовы API.
- **componentWillUnmount** – вызывается непосредственно перед удалением компонента из DOM. Используется для очистки ресурсов, которые были установлены в componentDidMount, например, для удаления слушателей событий или отмены таймеров.

Некоторые методы жизненного цикла (componentWillMount, componentWillReceiveProps и componentWillUpdate) уже устарели, вместо них используют альтернативные методы или хуки.
