### 1. Зачем нужен хук useEffect?

Хук `useEffect` позволяет нам выполнять побочные эффекты в функциональных компонентах. Это помогает нам избежать избыточного кода в различных методах жизненного цикла классового компонента. Это помогает сгруппировать связанный код.

### 2. Что делает хук useEffect в React

`useEffect` позволяет выполнять побочные эффекты в функциональных компонентах. Могут быть операции, которые выходят за рамки возвращаемого результата рендеринга (запрос данных, подписки, таймеры, ручное изменения DOM и тд). Запускается после каждого рендеринга компонента по умолчанию, поведение настраивается с помощью массива зависимостей.

### 3. Как работает массив зависимостей?

Массив зависимостей - второй (необязательный) аргумент, передаваемый в хук. Представляет собой массив значений, от которых зависит эффект.

- Массив не предоставлен - эффект выполняется после каждого рендера
- [] - эффект выполняться только один раз при монтировании компонента, аналогично componentDidMount в классовых компонентах
- [ переменные ] - эффект выполняется при изменении переменных.

### 4. Как осуществляется очистка в useEffect?

Для очистки в `useEffect`, функция, передаваемая в `useEffect`, может вернуть функцию очистки. React вызовет эту функцию перед тем, как компонент будет размонтирован, а так же перед следующим выполнение эффекта, если он повторно активируется. Используется для предотвращения утечек памяти.  
Пример использования очистки:

```javascript
import { useEffect, useState } from "react";

export default function Timer(): JSX.Element {
  const [count, setCount] = useState < number > 20;

  useEffect(() => {
    const timeCounter = setTimeout(() => {
      if (count > 0) {
        setCount((prev) => prev - 1);
      }
    }, 200);
    return () => clearTimeout(timeCounter); // функция очистки
  }, [count]);

  return <h2>{count ? `Timer: ${count}` : "Время вышло!"}</h2>;
}
```

### 5. Как избежать бесконечных циклов при использовании useEffect?

Бесконечные циклы возникают например, когда эффект обновляет состояние, на которое он сам зависит, без правильной настройки массива зависимостей. Для избежания этого необходимо проверить:

- Все перемененные, которые используются в эффекте и могут изменяться, включены в массив зависимостей;
- Используется пустой массив зависимостей, если эффект должен срабатывать только при монтировании и размонтировании;
- Следует избегать изменения состояния в эффекте, если это изменений может повторно активировать тот же эффект (только если это нее является преднамеренным поведением)ю

### 6. Разница между использованием useEffect и useLayoutEffect?

Оба хука позволяют выполнять дополнительные эффекты, такие как вызовы API, настройку подписок и манипулирование DOM вручную в функциональном компоненте, но при этом:

- **`useLayoutEffect`** выполняется синхронно до того, как браузер отрисует (обновит) эти обновления для просмотра пользователями. Подходит для чтения из DOM или для изменений, которые необходимо отобразить перед следующим отображение экрана, чтобы избежать возможного мерцания. Но так браузер не может отображать какие-либо обновления, пока не запустится `useLayoutEffect`. По этой причине в основном используется useEffect

- **`useEffect`** выполняется асинхронно после того, как браузер отрисует (обновит) экран. Является более подходящим для большинства дополнительных / побочных эффектов

**Код с использованием `useEffect`:**  
**DOM обновления** => _Браузер отображает обновление для просмотра пользователем_ => `useEffect` => **другое обновление DOM** => _Браузер отображает второе обновление для просмотра пользователем_

**Код с использованием `useLayoutEffect`:**  
**DOM обновления** => `useLayoutEffect` => **другое обновление DOM** => _Браузер отображает общее обновление для просмотра пользователем_
